<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仿饿了么踩到的坑]]></title>
    <url>%2F2018%2F04%2F20%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近在做2.0版本的饿了么,在慕课网上的教程是1.0版本的,在写到评价系统，遇到父子组件通讯的时候，遇到的困难，记录一下，巩固知识。 本意是想实现下面图片的功能，点击每个选项，动态的切换项目下面的list. 直接上代码： 错误代码 &lt;template&gt; ....省略样式... &lt;/template&gt; &lt;script&gt; const POSITIVE = 0; const NEGATIVE = 1; const ALL = 2; export default { props: { ratings: { type: Array, default() { return []; } }, selectType: { type: Number, default: ALL }, onlyContent: { type: Boolean, default: false }, desc: { type: Object, default() { return { all: &apos;全部&apos;, positive: &apos;满意&apos;, negative: &apos;不满意&apos; }; } } }, computed: { positives() { return this.ratings.filter((rating) =&gt; { return rating.rateType === POSITIVE; }); }, negatives() { return this.ratings.filter((rating) =&gt; { return rating.rateType === NEGATIVE; }); } }, methods: { select(type, event) { if (!event._constructed) { return; } this.typeSelect = type; this.$emit(&apos;select&apos;, type); }, toggleContent(event) { if (!event._constructed) { return; } this.selectContent = !this.onlyContent; this.$emit(&apos;toggle&apos;, this.selectContent); } } }; &lt;/script&gt; 父组件： &lt;ratingselect :onlyContent=&quot;onlyContent&quot; :selectType=&quot;selectType&quot; :ratings=&quot;ratings&quot; @select=&quot;selectRating&quot; @toggle=&quot;toggleContent&quot;&gt;&lt;/ratingselect&gt; export default{ props: { seller: { type: Object } }, data() { return { showFlag: false, ratings: [], selectType: ALL, onlyContent: true }; }, filters: { formatDate(time) { let date = new Date(time); return formatDate(date, &apos;yyyy-MM-dd hh:mm&apos;); } }, created() { this.$http.get(&apos;/api/ratings&apos;).then((res) =&gt; { res = res.data; // console.log(res); if (res.errno === ERR_OK) { this.ratings = res.data; this.$nextTick(() =&gt; { console.log(this.$refs); console.log(this.$el); this.scroll = new BScroll(this.$el, { click: true }); }); } }); }, methods: { needShow(type, text) { if (this.onlyContent &amp;&amp; !text) { return false; } if (this.selectType === ALL) { return true; } else { return type === this.selectType; } }, selectRating(type) { this.selectType = type; this.$nextTick(() =&gt; { this.scroll.refresh(); }); }, toggleContent() { this.onlyContent = !this.onlyContent; this.$nextTick(() =&gt; { this.scroll.refresh(); }); } }, components: { star, split, ratingselect } }; 按照视频和自己理解的2.0知识，子组件通过$emit（’自定义事件名’,’参数’）触发一个事件，并且把参数传递过去。子组件定义的函数在父组件中找到和它同名的函数（一般用@子函数名=父组件定义的函数名），并且把参数传递过去。父组件通过监听，知道子组件需要改变，于是，接收传递过来的参数，并且执行。在预览的时候没有问题，当点击到组件的时候，报错。 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop&apos;s value. Prop being mutated: &quot;xxx&quot; (found in component ) 按照文档给的解释是子组件只能被动接收父组件传递过来的数据，并在子组件内不能修改由父组件传递过来的props数据。每次父组件更新时，子组件的所有prop都会更新为最新值，因此不应该在子组件内部改变 prop，如果我们尝试直接修改prop 属性的值，就会有警告提示。 网上找了好多资料解决这个问题，都没有成功，无意间看到一篇博客，上面说，在子组件data中定义一个父组件传递过来的副本,再把该副本利用this.$emit(“”,””)给传回去，父组件利用自定义事件接受该值，意思是在子组件中声明一个中间变量，避免直接改变父组件传递过来的值。于是抱着试一下的心态，按照他说的，改了一下代码，果然不会再报错。 代码几乎没变，只是在子组件中多加了一个data函数，定义了一下，需要传递的数据 data() { return { typeSelect: this.selectType, selectContent: this.onlyContent } },]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组排序算法]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在工作中往往会需要对数据进行排序，高效的排序方法能够使程序有更好的性能。本文总结了常用的几种数组排序算法。 1 冒泡排序 冒泡排序的基本原理是，从数组的第一项开始，比较相邻的两项，如果前面的大于后面的就交换位置。这样循环下来，就把较大的项转移到了数组尾部。 //bubbleSort 冒泡排序 var arr = [1,9,6,10,3,7,8]; var bubbleSort = function(arr){ var len = arr.length, res = arr.slice(0); //避免污染源数组 for(var i = 0; i &lt; len; i++){//控制需要多少轮排序，第一轮转移最大值，第二轮次大值... for(var j = 0; j &lt; len - 1; j++){//相邻的两项做比较，每一轮循环完毕会把最大值转移到尾部 if(res[j] &gt; res[j+1]){ var temp = res[j]; res[j] = res[j+1]; res[j+1] = temp; } } } return res; }; bubbleSort(arr); //[ 1, 3, 6, 7, 8, 9, 10 ] 这种做法可以实现效果，但是有一个问题：在内层for循环执行一轮之后，数组中的最大值已经转移到数组最后一位了，但是下一轮循环依旧会拿其他值与该值做比较，这其实是不必要的。更合适的做法应该是执行完一轮之后第二次不必和最后一个值做比较；执行完第二轮之后不必和后两个做比较，以此类推。那么代码实现上，应该是内层循环的控制条件是 j &lt; len - 1 - n;此处的n是当前已经完成的循环次数，刚好与外层的i值相同。因此应该是j &lt; len - 1 - i. 完善之后的冒泡排序如下： var bubbleSort = function(arr){ var len = arr.length, res = arr.slice(0); for(var i = 0; i &lt; len; i++){ for(var j = 0; j &lt; len - 1 - i; j++){ if(res[j] &gt; res[j+1]){ var temp = res[j]; res[j] = res[j+1]; res[j+1] = temp; } } } return res; }; bubbleSort(arr); //[ 1, 3, 6, 7, 8, 9, 10 ] 2 选择排序 选择排序的基本原理是，遍历数组找到数组的最小值把它放置在第一位，在遍历找到第二小的值放到第二位…直到最后。 //selectSort 选择排序 var selectSort = function(arr){ var len = arr.length, res = arr.slice(0), minIndex; for(var i = 0; i &lt; len - 1; i++){ minIndex = i; for(var j = i + 1; j &lt; len; j++){ //遍历查找最小项 if(res[j] &lt; res[minIndex]){ minIndex = j; } } if(minIndex != i){ var temp = res[i]; res[i] = res[minIndex]; res[minIndex] = temp; } } return res; }; selectSort(arr); //[ 1, 3, 6, 7, 8, 9, 10 ]; 3 插入排序 插入排序的基本原理是，默认数组第一项已经在一个只有他自己的数组中排好序了，然后第二项与第一项做比较决定第二项在第一项之前还是之后，然后第三项与前两项做比较决定第三项的位置… //insertSort 插入排序 var insertSort = function(arr){ var len = arr.length, res = arr.slice(0), key,j; for(var i = 1; i &lt; len; i++){ key = res[i]; j = i - 1; while(j &gt;= 0 &amp;&amp; res[j] &gt; key){ res[j+1] = res[j]; j --; } res[j+1] = key; } return res; } insertSort(arr); //[ 1, 3, 6, 7, 8, 9, 10 ]; 在处理小型数组时，插入排序的性能要优于冒泡排序和选择排序。但是插入排序在排序进行到后期的时候，随着排序完成的项数的增加需要更多的比较次数。在此基础上提出的希尔排序，通过设置步长，将一个数组按步长分块，最后再将数组进行插入排序。 //shellSort 希尔排序 var shellSort = function(arr){ var res = arr.slice(0), len = res.length, gap = Math.floor(len / 2), key,j; while(gap &gt; 0){ for(var i = gap; i &lt; len; i++){ key = res[i]; j = i - gap; while(j &gt;= 0 &amp;&amp; res[j] &gt; key){ res[j+gap] = res[j]; j -= gap; } res[j+gap] = key; } gap = Math.floor(gap / 2); } return res; }; shellSort(arr); //[ 1, 3, 6, 7, 8, 9, 10 ]; 希尔排序是将数组按步长分为几个序列，分别进行直接排序；然后再缩短步长再次进行插入排序，直到步长足够小的时候，数组基本有序，再整体进行直接插入排序。由于这时候已经完成大部分排序，所以效率会比直接插入排序高一点。 4 归并排序 归并排序的基本原理是，将原始数组切分成较小的数组，直到每个数组只有一个位置，接着将小数组归并成较大的数组，完成排序。 //mergeSortRec 归并排序 var mergeSortRec = function(arr){ var res = arr.slice(0), len = res.length; if(len === 1){ return arr; } var mid = Math.floor(len / 2), left = res.slice(0,mid), right = res.slice(mid,len); return merge(mergeSortRec(left),mergeSortRec(right)); }; function merge(left,right){ var result = [], il = 0, ir = 0, llen = left.length, rlen = right.length; while(il &lt; llen &amp;&amp; ir &lt; rlen){ if(left[il] &lt; right[ir]){ result.push(left[il++]); }else{ result.push(right[ir++]); } } while(il &lt; llen){ result.push(left[il++]); } while(ir &lt; rlen){ result.push(right[ir++]); } return result; }; mergeSortRec(arr);//[ 1, 3, 6, 7, 8, 9, 10 ]; 5 快速排序 快速排序的基本思想类似于归并排序，设定数组中间项为基准，把原始数组分成2个小数组，比基准项小的在一个数组，比基准项大的在一个数组；然后对每个小数组重复分组，最终合并。 //quickSort 快速排序 var quickSort = function(arr){ var res = arr.slice(0), len = res.length; if(len &lt;= 1){ return res; } var index = Math.floor(len / 2), mid = res.splice(index,1)[0], left = [], right = []; for(var i = 0; i &lt; res.length; i++){ if(res[i] &lt; mid){ left.push(res[i]); }else{ right.push(res[i]); } } return quickSort(left).concat([mid],quickSort(right)); }; quickSort(arr); //[ 1, 3, 6, 7, 8, 9, 10 ]; 上文的这几种排序方法的效率是按顺序提升的。快速排序是使用的最广泛、效率最高的排序算法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端面试题(二)]]></title>
    <url>%2F2017%2F01%2F17%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.如何把URL参数解析为一个对象 var url = &quot;http://www.taobao.com/index.php?key0=0&amp;key1=1&amp;key2=2&quot;; function decode(url) { var str = url.split(&quot;?&quot;)[1], var item = str.split(&quot;&amp;&quot;); var result = {}; var arr; for (var i = 0; i &lt; item.length; i++) { arr = item[i].split(&quot;=&quot;); result[arr[0]] = arr[1]; } return result; } decode(url) 2.你有用过哪些前端性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。 3.用js实现千位分隔符? function format(num){ num=num+&apos;&apos;; var str=&apos;&apos;; for(var i=num.length-1,j=1;i&gt;=0;i--,j++){ if(j%3==0&amp;&amp;i!=0){ str+=num[i]+&apos;,&apos;; continue; } str+=num[i] } return str.split(&apos;&apos;).reverse().join(&apos;&apos;); } alert(format(12345678912)) 4.移动端前端开发与PC端比有哪些不同？ 1.pc端没有触摸的各种事件，移动端有；移动端没有鼠标移入移出事件，但是pc端有 2.Pc端最常用的布局是固定宽度为980px（也有960px，1000px，1200px）；而在移动端，因为有很多网页是可以横屏看也可以竖屏看，并且很多屏幕的饿分辨率都是不一样的，所以只要牵涉到移动端都要考虑用响应式布局 3.Pc布局考虑更多的是浏览器的兼容性，但是在移动端，考虑更多的是手机兼容性，因为手机的型号类型非常的多，导致屏幕的分辨率是不一样的 4.移动端触摸弹出的手机键盘处理也是在pc端不会遇到的问题。 5.移动端和pc端适用的js框架也是不一样 6.Pc端浏览器内核有很多，webkit，Gecko，。。。。，但是移动端的浏览器内核比较单一，基本都是webkit以及webkit相关的blink 7.Pc端的交互是鼠标，键盘的交互而移动端变成了触摸，手势的交互 5.我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，会执行几次事件，会先执行冒泡还是捕获？ 绑定在被点击元素的事件是按照代码的顺序发生的，其他非绑定的元素则是通过冒泡或者捕获的触发。按照W3C的标准，先发生捕获事件，后发生冒泡事件。所以事件的整体顺序是：非目标元素捕获 -&gt; 目标元素代码顺序 -&gt; 非目标元素冒泡。 6.移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？ 大概有300ms的延时 来源是因为safari浏览器的双击缩放事件。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。其他浏览器都复制了safari的这种约定。 1.用zeptoJs中的tap事件来代替click 2.FastClick 它的核心思想是取消默认的click时间，判断当前dom节点的类型进行相应的操作 FastClick 的使用方法非常简单，在 window load 事件之后，在body上调用FastClick.attach()即可。 window.addEventListener( &quot;load&quot;, function() { FastClick.attach( document.body ); }, false ); 7.写一个函数，[1,2,3,4,5]=&gt;[1,2,3,4,5,1,2,3,4,5] function clone() { var arr=[1,2,3,4,5]; var len=arr.length; for(var i=0;i&lt;len;i++){ var b= arr[i]; arr.push(b); } return arr; } alert(clone()); 8.JavaScript原型，原型链 ? 有什么特点？ 每个函数（构造函数）都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象（原型对象），而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 访问一个对象的属性时，先在基本属性中查找，如果没有，继续向上找，找到object原型，这就是原型链 使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法。 JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。 不能用字面量创建原型的方法，这样做会重写原型链。 不要在原型对象中定义属性的，否则会被所有实例共享。 9.什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 1，什么是前端路由？ 路由是根据不同的 url 地址展示不同的内容或页面 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。 2，什么时候使用前端路由？ 在单页面应用，大部分页面结构不变，只改变部分内容的使用 3，前端路由有什么优点和缺点？ 优点 用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点 使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置 10.Javascript如何实现继承？ 1.原型链继承 核心： 将父类的实例作为子类的原型 function animal(){ this.name=function(){ console.log(&apos;我有名字&apos;); } } function cat() { this.climb=function(){ console.log(&apos;我会爬树&apos;) } } function tiger(){ this.type=function(){ console.log(&apos;我是老虎&apos;) } } cat.prototype=new animal(); tiger.prototype=new cat(); var _child=new tiger(); console.log(_child.name()); console.log(_child.climb())； 2.构造继承 function Person(name,age){ this.name=name; this.age=age; } function Child(name,age,job){ Person.call(this,name,age); this.job=job; } var _child=new Child(&apos;lucy&apos;,&apos;16&apos;,&apos;星灵魔法师&apos;); alert(_child.name) alert(_child.age) 3.混合继承 function Person(name,age){ this.name=name; this.age=age; } Person.prototype.sayhellow=function(){ alert(&apos;hello,我叫&apos;+this.name+&apos;今年&apos;+this.age) } function Student(name,age,job){ Person.apply(this,[name,age]); //Person.apply(this,arguments); // Person.apply(this,name,age) this.job=job; }; Student.prototype.sayhellow=function(){ alert(&apos;hello,我叫&apos;+this.name+&apos;\n&apos;+&apos;今年&apos;+this.age+&apos;\n&apos;+&apos;我是一名&apos;+this.job) }; var student=new Student(&apos;lucy&apos;,&apos;16&apos;,&apos;星灵魔法师&apos;) student.sayhellow(); 11.Javascript创建对象的几种方式？ 1.简单对象的创建 使用对象字面的方式{} var Cat = {}; Cat.name=&quot;kity&quot;;//添加属性并赋值 Cat.age=2; Cat.sayHello=function(){ alert(&quot;hello &quot;+Cat.name+&quot;,今年&quot;+Cat[&quot;age&quot;]+&quot;岁了&quot;);//可以使用“.”的方式访问属性，也可以使用HashMap的方式访问 } Cat.sayHello();//调用对象的（方法）函数 2.用function(函数)来模拟构造函数 function Person(name,age){ this.name=name; this.age=age; this.job=function(){ alert(&quot;我叫&quot;+this.name+&quot;,今年&quot;+this.age+&quot;,我的职业是教师&quot;); } } var person=new Person(&apos;jack&apos;,&apos;26&apos;); person.job() 3.使用工厂方式来创建（Object关键字） function Person(name,age){ var obj=new Object(); obj.name=name; obj.age=age; obj.showName=function(){ return this.name }; obj.showAge=function(){ return this.age }; return obj; } var _child=new Person(&apos;张三&apos;,&apos;25&apos;); alert(_child.showName()); alert(_child.showAge()); 4.使用原型对象的方式 prototype关键字 function Dog() {}; Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function(){ alert(this.name+&quot;是个吃货&quot;) } var dog=new Dog(); dog.eat(); 5.混合模式(原型和构造函数) function Person(name,age) { this.name=name; this.age=age; } Person.prototype.showJob=function(){ alert(&quot;我的名字是&quot;+this.name+&quot;,今年&quot;+this.age+&quot;岁,我的职业是灭龙魔法师 &quot;) } var person=new Person(&quot;natsu&quot;,&quot;16&quot;); person.showJob(); 12.写一个快速排序的算法 function sort(arr){ if (arr.length &lt;= 1){return arr}; var left=[]; var right=[]; var midIndex=Math.floor(arr.length / 2); var mid=arr.splice(midIndex,1); var len=arr.length; for(var i=0;i&lt;len;i++){ if(arr[i]&gt;mid){ right.push(arr[i]) }else{ left.push(arr[i]); } } return sort(left).concat(mid,sort(right)); } var arr=[55,5,26,12,-20,34,88,49,66,78]; alert(sort(arr)); 13.Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。 14.谈谈This对象的理解。 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； 15.new操作符具体干了什么呢? 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 16.Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ hasOwnProperty javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 17.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ AMD 异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 CMD 通用模块定义。执行顺序和书写顺序是完全一致，加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块。 区别： 1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。 2. CMD 推崇依赖就近，只有在用到某个模块的时候再去require。AMD 推崇依赖前置。在定义模块的时候就要声明其依赖的模块。 18.requireJS的核心原理是什么 1、载入模块 2、通过模块名解析出模块信息，以及计算出URL 3、通过创建SCRIPT的形式把模块加载到页面中。 4、判断被加载的脚本，如果发现它有依赖就去加载依赖模块。如果不依赖其它模块，就直接执行factory方法 5、等所有脚本都被加载完毕就执行加载完成之后的回调函数 19.GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值， 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 20.AJAX的优缺点 Ajax的最大的特点是什么。 Ajax可以实现动态不刷新（局部刷新） ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 5、不容易调试。 21.网站重构的理解？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 22.Web Worker 和webSocket worker主线程: 1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。 2.通过worker.postMessage( data ) 方法来向worker发送数据。 3.绑定worker.onmessage方法来接收worker发送过来的数据。 4.可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询 23.HTTP和HTTPS,为什么HTTPS安全 HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端面试题（一）]]></title>
    <url>%2F2017%2F01%2F11%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[HTML&amp;&amp;CSS1.简述&lt;!DOCTYPE&gt;标签的定义与用法 &lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前， 告诉浏览器按照何种规范解析页面。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 2.块级元素和行内元素有哪些？ 块级元素：div p h1 h2 h3 h4 h5 h6 form ul ol 行内元素：span b i a input select 3.cookie的属性都知道哪些？ Cookie是一种以文件的形式保存在客户端硬盘的Cookies文件夹中的用户数据信息(Cookie数据)。 Name: 获取或设置Cookie的名称 value: 获取或设置Cookie的Value Expires: 获取或设置Cookie的过期时间和事件 Version: 获取或设置Cookie的符合HTTP维护状态的版本 Path: 获取或设置Cookie的路径，指定与cookie关联的web页 Domain: 域，指定关联的web服务器或域。 Secure:安全。指定cookie的值通过网络如何在用户和web服务器间的传递（加密） 4.简述cookie的操作？ get: 通过变量名称或索引得到Cookie的变量值 Add:增加cookie变量 Clear：清除cookie集合内的变量 Remove:通过cookie变量名称或索引删除cookie对象 5.http协议的状态消息都有哪些？（如200,302对应的描述） 1开头表示请求收到，继续处理；2开头表示成功返回； 3开头表示请求被重定向； 4开头表示由于客户端造成的错误； 5开头表示由于服务端造成的错误。 100 客户必须继续发送请求 101 客户要求服务器根据请求转换http协议版本 200 成功处理了请求 201 请求成功并且服务器创建了新的资源。 202 服务器已接受请求，但尚未处理。 300 请求的资源可在多处得到 301 删除请求数据 302 在其他地址发现了请求的数据 303 建议客户端访问其他url或访问方式 401 请求未授权 403 服务器拒绝请求 404 服务器找不到请求的网页 500 最常见的服务器端错误。 6.主流css的引入方式，link和@import的区别是? 内联 内嵌 外链 导入 区别 ：页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; 前者无兼容性，后者CSS2.1以下浏览器不支持 Link 支持使用javascript改变样式，后者不可 7.css盒模型 标准盒模型：margin padding border content 并且 content 部分不包含其他部分 ie盒模型： margin padding border content 但是content 部分包含border和padding 8.怎么做到垂直水平居中 1.定位 div { width:400px; height:300px; position:absolute; left:50%; top:50%; margin-left:-200px; margin-top:-150px; background:#f90; } 2.CSS3的flex实现水平方法,但是兼容性差。 div{ display:-webkit-flex; align-items：center； justify-content:center; } **div实现水平居中： div{ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; //还需写其他浏览器兼容,把前缀改成-moz,o-,-ms display: box; box-orient: horizontal; box-pack: center; } 9.如何使文本溢出边界显示为省略号 .test{width:150px;white-space:nowrap;over-flow:hidden;text-overflow:ellipsis} 10.css选择器有哪些？优先级顺序是什么，哪些属性可以继承 全局选择器，标签选择器，类选择器，id选择器， 组合选择器 伪类选择器，字符串匹配的属性选择符 优先级 全局选择器&gt;id选择器&gt;类选择器&gt;标签选择器 color，font-size可以继承 11.清除浮动的几种方式 1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，增加无意义的标签） 2.使用overflow（空标签元素清除浮动而不得不增加无意代码的弊端,使用zoom:1用于兼容IE） 3.是用afert伪元素清除浮动(用于非IE浏览器) 12.CSS隐藏元素的几种方法 1.opacity:元素本身依然占据它自己的位置并对网页布局起作用。响应用户交互 2.display：none 任何对该元素进行用户交互操作都不可能生效，读屏软件也不会督导元素的内容。效果就像元素完全不存在。 3.visibility:不会响应用户交互。 4.position：不会影响布局，能让元素可以操作。 13.css3有哪些新特性 圆角（border-radius），阴影（box-shadow），文字特效（text-shadow），线性渐变（gradient），旋转（transform） transform：rotate，scale，translate skew//旋转，缩放，位移，倾斜 14.h5增加了哪些新特性 HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式； 当然也可以直接使用成熟的框架、比如html5shim; &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 15.请描述 cookies、sessionStorage 和 localStorage 的区别 1.cookie在浏览器和服务器间来回传递。其他两个不会，只会在本地生效。 2.sessionStroage和localStorage的存储空间较大，大小为5M，cookie较小，4kb 3.sessionStroage和localStorage有更多丰富易用的接口，cookie需要自己封装，原生的接口不友好。 4.sessionStroage和localStorage有各自独立的存储空间。 5.localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个会话，一旦浏览器的关于该会话的页面关闭了，sessionStorage就消失了。 16.请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别。 1.没有async或者defer，浏览器会立即加载并执行指定的脚本。 2.有async，整个脚本就可以异步加载和执行。 3.有defer，告诉浏览器这段script不必立即执行，那么浏览器就会在完全载入文档之后再执行这个script，相当于window.onload。 17.为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？ css和JavaScript不一定写在head里比较好，单独设立css和js文件，把代码写在里面，这样方便查找和管理. 而CSS和js的引用位置是放在头部还是尾部取决于一个加载顺序，在网页传输过程当中，浏览器会先加载html，当加载头部以后会同步加载头部中引用的文件，而css样式表在这里加载会规定网页的总体样式，js如果需要先加载后运行则写在头里，需要其他内容加载完之后在运行则可以写在尾部。 18.使用 data- 属性的好处是什么？ 方便js直接调用自定义属性。 19.请描述 BFC(Block Formatting Context) 及其如何工作。 BFC:块级格式化上下文 浮动元素和绝对定位元素，非块级盒子的块级容器（如inline-block,talble-cell和table-caption）以及overflow值不为&quot;visiable&quot;的块级盒子，都会为他们的内容创建新的块级格式化上下文 在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。两个相邻的块级盒子的垂直外边距会发生叠加。 在块级格式化上下文中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。 20.描述z-index和叠加上下文是如何形成的 z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 元素可拥有负的 z-index 属性值。 Z-index 仅能在定位元素上奏效（例如 position:absolute;）！ 该属性设置一个定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远 21..display中block，inline和inline-block的概念以及区别 display：block： block元素会独占一行，多个block元素会各自新起一行。 block元素可以设置width，height属性。 block可以设置margin和padding属性 display：inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排不下，才会另一起一行。 宽度随元素的内容而变化 inline设置width，height无效 inline元素的margin和padding属性，水平方向都产生边距效果，但竖直方向不会产生边距效果 display：inline-block 将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内 属性为inline-block的元素之间的空格或者换行在浏览器上会是一个空白的间隙。ie6,7不支持这个属性。通过*display：inline；*zoom：1做hack处理 22.浏览器渲染页面的过程 当浏览器获得一个html文件时，会”自上而下“加载，并在加载过程中进行解析渲染 1.渲染引擎开始解析HTML文档，重建dom树，转换树中的标签到DOM节点 2.解析css,根据css选择器计算出节点的样式，创建另一个树--渲染树 3.从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标 4.遍历渲染树，每个节点将使用ui后端层来绘制 主要的流程就是：构建一个dom树，页面要显示的各元素都会创建到这个dom树当中，每当一个新元素加入到这个dom树当中，浏览器便会通过css引擎查遍css样式表，找到符合该元素的样式规则应用到这个元素上。 23.HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)， 通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。 之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 24.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件， 如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。 如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了， 那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 25.简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 26.iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。 27.HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 28.如何实现浏览器内多个标签页之间的通信? WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； 29.如何设置小于12px的字体 Chrome27正式取消了-webkit-text-size-adjust属性，所有字号最小为12px。 如果希望设置为9px效果，可以重新使用一个div包裹文字，并对此div使用： div{ font-size: 9px; transform: scale(0.75); } 12×0.75=9； 用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 30.CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled 选择器匹配每个已启用的元素（大多用在表单元素上）。 :disabled 选择器匹配每个被禁用的元素（大多用在表单元素上） :checked 单选框或复选框被选中。 31.position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值。 32.用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） .triangle{ width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; } 33.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符, 这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 34.如何修改chrome记住密码后自动填充表单的黄色背景 ？ input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0); } 貌似这个方法不行了。 35.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb{ background-color:red;/*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ } IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} JavaScript1.介绍js的基本数据类型 5种基本数据类型Undefined、Null、Boolean、Number、String 还有一种复杂的数据类型 Object 2.null，undefined 的区别？ null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined的类型(typeof)是undefined； null的类型(typeof)是object；(null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。) null是一个表示&quot;无&quot;的对象，转为数值时为0； undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN。 注意： null==undefined//true ECMAScript认为undefined是从null派生出来的，所以把它们定义为相等的。 null===undefined//false 3.typeof instanceof constructor的区别 typeof返回一个表达式的数据类型的字符串，返回结果为js基本的数据类型， 包括number,boolean,string,object,undefined,function. 语法为typeof(data) 或 typeof data instanceof则为判断一个对象是否为某一数据类型，或一个变量是否为一个对象的实例; 返回boolean类型 constructor是Object的一个属性，他指向：创建对象的函数的引用（指针）。 （可以理解为constructor指向对象的构造函数） typeof instanceof都是运算符，constructor不是运算符，是对象的一个属性 4.数组和字符串有哪些原生方法，列举一下 数组：sort，concat，splice，toString，push，pop，join,shift,unshift,reverse,slice,valueOf,toSource,toLocaleString 字符串：charAt,charCodeAt,concat,indexOf,split,match,substring,sub, toLowerCase,toUpperCase,valueOf,replace,sup,toString,fromCharCode 5.例举3种强制类型转换和2种隐式类型转换 强制 Boolean,Number,toString 隐式 - == === Boolean 当要转换的值是至少有一个字符的字符串、非0数字或对象时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null,它将返回false 6.parseInt和parseFLoat parseInt()方法首先查看位置0处的 字符，判断它是否是个有效数字；如果不是，该方法将返回NaN 如果该字符是有效数字，该方法将查看位置1处的字符，进行同样的 测试。这一过程将持续到 发现非有效数字的字符为止 parseInt还可以指定第二位参数来指定转换结果的进制(2,8,16) parseFloat与parseInt()方法的处理方式相似,不过，第一个出现的小数点是有效字符. 例如，parseInt（&apos;5.12.4abc&apos;）输出5，parseFloat(&apos;5.12.4abc&apos;) 输出5.12 parseInt(&apos;0xA&apos;) 输出10，parseInt(&apos;0cA&apos;) 输出 0；parseFloat(&apos;0xA&apos;)输出 0 7.如何实现数组的随机排序 1 var arr=[1,2,3,4,5,6,7,8,9,10]; arr.sort(function(){ return Math.random()-0.5 }); document.write(arr) 2 var arr = [1,2,3,4,5,6,7,8,9,10]; function sortArr(arr){ for(var i=0;i&lt;arr.length;i++){ var rand=parseInt(Math.random()*arr.length); var temp=arr[rand]; arr[rand]=arr[i]; arr[i]=temp; } return arr; } document.write(sortArr(arr)) 3. var arr = [1,2,3,4,5,6,7,8,9,10]; function sortArr(arr){ var randArr = []; while(arr.length &gt; 0){ var rand = parseInt(Math.random()*arr.length); randArr.push(arr[rand]); arr.splice(rand, 1); } return randArr; } document.write(sortArr(arr)); 8.Javascript的事件流模型都有什么？ 事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 9.事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 事件是我们在网页中的某个操作（有的操作对应多个事件）。 例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件； ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 10.函数声明与函数表达式的区别 在js中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）， 至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。 11.js的基础对象有那些, window和document的常用的方法和属性列出来 String,Number,Boolean Window: 方法：setInterval,setTimeout,clearInterval,clearTimeout,alert,confirm,open 属性：name,parent,screenLeft,screenTop,self,top,status Document 方法：createElement_x,execCommand,getElementById,getElementsByName,getElementByTagName,write,writeln 属性：cookie,doctype,domain,documentElement,readyState,URL, 12.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。 （2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 （3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。 （4），此时，`Web`服务器提供资源服务，客户端开始下载资源。 13.javascript事件代理(委托),手写事件代理，并考虑兼容 事件代理就是在祖先级DOM元素绑定一个事件，当触发子孙级DOM元素的事件时，利用事件流的原理来触发绑定在祖先级DOM的事件 好处： 性能得到了优化 动态添加的元素也能绑定事件 var EventUtil = { addHandler: function(element, type, handler){ if(element.addEventListener){ element.addEventListener(type, handler, false); //false冒泡时触发 }else if(element.attachEvent){ element.attachEvent(&quot;on&quot; + type, handler); }else{ element[&quot;on&quot; + type] = handler; } }, removeHandler: function(element, type, handler){ if(element.removeEventListener){ element.removeEventListener(type, handler, false); }else if(element.detachEvent){ element.detachEvent(&quot;on&quot; + type, handler); }else{ element[&quot;on&quot; + type] = null; } }, getEvent: function(event){ return event?event:window.event; }, getTarget: function(event){ return event.target || event.srcElement; //事件的实际目标 }, preventDefault: function(event){ //取消时间的默认行为 if(event.preventDefault){ event.preventDefault(); }else{ event.returnValue = false; } }, stopPropagation: function(event){ //立即停止事件的传播（取消捕获、冒泡） if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble = true; } } } 14.闭包是什么，有什么特性，对页面有什么影响 闭包就是能够读取其他函数内部变量的函数,而函数内部定义的变量外部不可访问 闭包有三个特性: 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 由于闭包时，变量的值都保存到内存中，会导致页面加载时内存消耗很大，IE会导致内在泄露，因此尽量少用或用时要及时删除变量。 15.下面代码输出什么 1 var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ return function(){ return this.name; } } }; console.log(object.getNameFunc()()) 答案是 The Window 因为每个函数被调用的时候其活动对象都会自动获取2个特殊的变量：this 和 arguments。 内部函数搜索这两个变量只会在其活动对象内搜索为止，永远不可能直接访问外部函数中的这两个变量 在这个代码中，函数执行function（）{return this.name};通常在一个方法里又声明一个函数，这个函数里面的this指向window。 2 var x=3; var foo={ x:2, baz:{ x:1, bar:function(){ return this.x } } } var go=foo.baz.bar; console.log(go()); console.log(foo.baz.bar()) 答案是3,1 go() 相当于变量go调用了function（）{return this.x}，this指向window foo.baz.bar() 这个就是foo.baz调用了bar（）函数所以this指向调用者foo.baz这个对象 16.this对象的理解 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 17.DOM怎样添加、移除、移动、复制、创建和查找节点 创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 18.JS 获取浏览器中信息 网页可见区域宽: document.documentElement.clientWidth; 网页可见区域高：document.documentElement.clientHeight; 滚 动 距 离：document.documentElement.scrollTop（ie）||document.body.scrollTop 浏览器所有内容高度： document.documentElement.scrollHeight 内 容 宽：obj.scrollWidth 内 容 高：obj.scrollHeight 获取盒子模型的宽度：obj.offsetWidth 获取盒子模型的高度：obj.offsetHeight 获取距离定位父级的左侧距离：obj.offsetLeft 获取距离定位父级的上侧距离：obj.offsetTop 19.new操作符具体干了什么 （1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 （2）属性和方法被加入到 this 引用的对象中。 （3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 20.JSON 的了解 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。 格式：采用键值对，例如：{&apos;age&apos;:&apos;12&apos;, &apos;name&apos;:&apos;back&apos;} JSON字符串转换为JSON对象: var obj =eval(&apos;(&apos;+ str +&apos;)&apos;); var obj = str.parseJSON(); var obj = JSON.parse(str); JSON对象转换为JSON字符串： var last=obj.toJSONString(); var last=JSON.stringify(obj); 21.call() 和 apply() 的区别和作用？ 对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 例如 function.call(this,1,2,3)； function.apply(this,[1,2,3]); 举例 function add(a,b) { alert(a+b); } function sub(a,b) { alert(a-b); } add.call(sub,3,1); 答案是 4，意思是sub对象调用add对象的方法 22.什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用 23.哪些常见操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 24.线程与进程的区别 一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 25.javascript的原生对象，内置对象和宿主对象 原生对象为array String obj regexp等可以new实例化 内置对象为gload Math 等不可以实例化的 宿主对象为浏览器自带的document,window 等 26.javascript的同源策略 一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 27.js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js 28.同步和异步的区别? 同步：脚本会停留并等待服务器发送回复然后再继续 异步：脚本允许页面继续其进程并处理可能的回复 29.Ajax 是什么? 如何创建一个Ajax？ Ajax是多种技术组合起来的一种浏览器和服务器交互技术，基本思想是允许一个互联网浏览器向一个远程页面/服务做异步的http调用，并且用收到的数据来更新一个当前web页面而不必刷新整个页面。该技术能够改进客户端的体验。 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新 封装的原生代码 function json2url(json){ json.t=Math.random(); var arr=[]; for(var name in json){ arr.push(name+&apos;=&apos;+encodeURIComponent(json[name])); } return arr.join(&apos;&amp;&apos;); } function ajax(json){ json=json||{}; if(!json.url)return; json.data=json.data||{}; json.type=json.type||&apos;get&apos;; json.timeout=json.timeout||6000; if(window.XMLHttpRequest){ var oAjax=new XMLHttpRequest(); }else{ var oAjax=new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); } switch(json.type.toLowerCase()){ case &apos;get&apos;: oAjax.open(&apos;GET&apos;,json.url+&apos;?&apos;+json2url(json.data),true); oAjax.send(); break; case &apos;post&apos;: oAjax.open(&apos;POST&apos;,json.url,true); oAjax.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); oAjax.send(json2url(json.data)); break; } json.loading&amp;&amp;json.loading(); //超时 var timer=setTimeout(function (){ json.complete&amp;&amp;json.complete(); oAjax.onreadystatechange=null; json.error&amp;&amp;json.error(&apos;失败！&apos;); },json.timeout); oAjax.onreadystatechange=function (){ if(oAjax.readyState==4){ if(oAjax.status==200){ json.complete&amp;&amp;json.complete(); clearTimeout(timer); json.success&amp;&amp;json.success(oAjax.responseText); }else{ json.error&amp;&amp;json.error(oAjax.status); } } }; } 30.Ajax 解决浏览器缓存问题？ 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。 3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。 4、在URL后面加上时间搓：&quot;nowtime=&quot; + new Date().getTime();。 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 31.如何解决跨域问题? 1.jsonp 原理就是利用script没有跨域限制的漏洞来达到与第三方通讯的目的。当需要通讯时，创建一个script元素， 地址指向第三方的API地址，并提供一个回调函数来接收数据（函数名可指定，形如 http://demo.hpyer.cn/php/jsonp.php? type=json&amp;callback=?，？为要执行的回调方法），第三方产生的响应为json数据的包装（故称之为jsonp），这样浏览器会调用callback函数， 并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据 举例 &lt;script type=&quot;text/javascript&quot;&gt; function jsonpCallback(result) { alert(result.msg); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/jsonServerResponse?jsonp=jsonpCallback&quot;&gt;&lt;/script&gt; 2.动态创建script 3.window.name+iframe 4.location.hash+iframe 5.postMessage 6.CORS CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 7.web sockets [详情](http://blog.csdn.net/joyhen/article/details/21631833) 32.在jQuery中，我们可以使用什么方法实现URL的编码和解码 编码 encodeURIComponent(url) 解码 decodeURIComponent(url) 33 escape（）encodeURI()和encodeURIComponent() 之间的区别 js对文字进行编码涉及3个函数：escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent 1.escape() 说明：对 String 对象编码以便它们能在所有计算机上可读， （1）该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。 （2）escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z （3）ECMAScript v3 反对使用该方法， escape 方法不能够用来对统一资源标示码 (URI) 进行编码，应用使用 decodeURI() 和 decodeURIComponent() 替代它。 2.encodeURI() 说明：将文本字符串编码为一个有效的统一资源标识符 (URI) （1）该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,# （2）如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。 （3）encodeURI不编码字符有82个：!，#，$，&amp;，&apos;，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z (4) 进行url跳转时可以整体使用encodeURI 如：Location.href=encodeURI(&quot;http://cang.baidu.com/do/s?word=百度&amp;ct=21&quot;); 3.encodeURIComponent() 将文本字符串编码为一个统一资源标识符 (URI) 的一个有效组件。 (1)该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) 。其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 (2)请注意 encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。 (3)encodeURIComponent不编码字符有71个：!， &apos;，(，)，*，-，.，_，~，0-9，a-z，A-Z (4) 传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。 如：&lt;script language=&quot;javascript&quot;&gt;document.write(&apos;&lt;a href=&quot;http://passport.baidu.com/?logout&amp;aid=7&amp; u=&apos;+encodeURIComponent(&quot;http://cang.baidu.com/bruce42&quot;)+&apos;&quot;&gt;退出&lt;/a&amp; gt;&apos;);&lt;/script&gt; 34.请解释变量声明提升 (hoisting) 变量提升即所有声明变量或声明函数都会被提升到当前函数的顶部。 如 (function(){ a = 5; alert(window.a); var a = 10; alert(a); })(); js解析时，会把函数变成 (function(){ var a; a = 5; alert(window.a); a = 10; alert(a); })();// undefined 10 35.请描述事件冒泡机制 当为多个嵌套的元素设置了相同的事件处理程序，它们将触发事件冒泡机制。在事件冒泡中，最内部的元素将首先触发其事件，然后是栈内的下一个元素触发该事件，以此类推，直到到达最外面的元素。如果把事件处理程序指定给所有的元素，那么这些事件将依次触发 取消事件冒泡机制。IE中的属性：cancelBubble，Mozila中的属性：stopPropagation。 解决事件冒泡的问题可以用事件委托，把事件绑定到发生事件的祖父节点（最高级别）让它来完成逻辑]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决js闭包for循环中i的问题]]></title>
    <url>%2F2017%2F01%2F06%2F%E8%A7%A3%E5%86%B3js%E9%97%AD%E5%8C%85for%E5%BE%AA%E7%8E%AF%E4%B8%ADi%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[闭包 闭包是前端面试经常问到的问题。所谓闭包，就是能够读取其他函数内部变量的函数。闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 函数内部可以直接读取全局变量 举例： for(var i=0;i&lt;10;i++){ setTimeout(function() { console.log(i) }, 1000); } 这个结果会打印10个10，而不是想象的0,1,2,3…… JS是单线程的,意味着同一时间只能执行一条语句,所以每个JS执行代码块都会阻塞异步事件的执行,这就意味着当一个异步(鼠标点击事件,ajax,settimeout)发生的时候,他们将排在执行队列的最后等待执行.setTimeout是异步的，里面的匿名函数作为setTimeout的第一个参数，作为回调函数等会执行。所以上面代码执行的时候，setTimeout被添加到队列的后面等待执行。for循环中的变量 i 一直在变, 最终会变成10, 而循环每次执行setTimeout时, 其中的方法还没有真正运行, 等真正到时间执行时, i 的值已经变成 10 了! 即i=0,执行setTimeout(function () {console.log(i);}), i=1,执行setTimeout(function () {console.log(i);}), i=2,执行setTimeout(function () {console.log(i);}), ....... 1s后到外部作用域寻找i,此时i早已经等于10，所以输出10个10. for循环中i变化的整个过程是瞬间完成的, 总之比异步要快, 就算你setTimout是0毫秒也一样, 会先执行完成. 在这个代码中，setTimeout中的匿名函数没有将i作为参数传入来固定这个变量是值，让其保留下来, 而是直接引用了外部作用域中的 i, 因此 i 变化时, 也影响到了匿名function.用闭包修改后： for (var i = 0; i &lt; 10; i++) { (function(a) { // 变量 i 的值在传递到这个作用域时被复制给了 a, // 因此这个值就不会随外部变量而变化了 setTimeout(function() { console.log(a); }, 1000); })(i); // 我们在这里把i传给a, } ES6提供了一个let来解决这个问题。 let使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。 当let声明出现在循环体里时拥有和var完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域，所以上面例子中，只用let声明就可以了 for(let i=0;i&lt;10;i++){ setTimeout(function() { console.log(i) }, 1000); } 会输出和预料一样的结果，0,1,2,3……10]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类似旋转木马效果]]></title>
    <url>%2F2017%2F01%2F06%2F%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[前言用纯原生javascript写的类似旋转木马的图片3D效果。实现图片由远及近，由大变小。 思路1.布局 首先，定义一个容器，设定宽，高，超出部分隐藏。准备7张图片，放在容器中。因为要让图片看起来有3D效果，所以，图片的大小应该不一样，看起来远的图片，图片要小一些，模糊度也低一些。中间图片的层次设为最高，两边对称的减小。如图： css代码如下 *{ margin: 0; padding:0; list-style: none; } .cantainer{ width:1000px; height: 400px; margin:50px auto; overflow: hidden; position: relative; } ul{ height: 400px; position: absolute; } ul li{ position: absolute; } ul li img{ width:100%; height: 100%; } ul li:nth-child(1){ width:96px; height: 63px;left:2px; top:-80px; z-index: 1;opacity: 0.25； filter: alpha(opacity=25) } ul li:nth-child(2){ width:288px; height:180px;left:88px;top:110px;z-index: 2; opacity: 0.5; filter: alpha(opacity=50); } ul li:nth-child(3){ width: 384px; height: 240px; left: 174px; top: 80px; z-index: 3;opacity: 0.75; filter: alpha(opacity=75) } ul li:nth-child(4){ width: 480px; height: 300px; left: 260px; top: 50px; z-index: 4;opacity: 1;filter:alpha(opacity=100) } ul li:nth-child(5){ width: 384px; height: 240px; left: 442px; top: 80px; z-index: 3;opacity: 0.75; filter: alpha(opacity=75) } ul li:nth-child(6){ width: 288px; height: 180px; left: 624px; top: 110px; z-index: 2; opacity: 0.5; filter: alpha(opacity=50); } ul li:nth-child(7){ width: 96px; height: 63px; left: 902px; top: -80px; z-index: 1; opacity: 0.25; filter: alpha(opacity=25) } a{ display: none; } #left{ width: 86px; height: 86px; background: url(img/arrow1.png) no-repeat 0 0 ; position: absolute; left:218px; top:150px; z-index: 10; } #right{ width: 86px; height: 86px; background: url(img/arrow2.png) no-repeat 0 0 ; position: absolute; top:150px; right:218px; z-index: 10; } 2 js 鼠标移入移出，左右按钮出现隐藏太简单，就不再赘述。关键在于，鼠标点击左右按钮后，图片的运动让它看起来有3D效果。 2.1 首先，将各个图片的位置信息，保存在一个数组中 for(var i=0;i&lt;aLi.length;i++){ arr.push({ left:aLi[i].offsetLeft, top:aLi[i].offsetTop, width:aLi[i].offsetWidth, height:aLi[i].offsetHeight, opacity:getStyle(aLi[i],&apos;opacity&apos;), zIndex:getStyle(aLi[i],&apos;z-index&apos;) }) } 2.2 对左右两个按钮添加点击事件 点击右边按钮的时候，将数组中第一个元素取出，插入到数组的后面。arr.push(arr.shift()); 当前元素位置减1。每次点击一下，都把当前第一个元素取出，插入末尾，这样就可以形成一个循环。点击左边按钮的时候，正好相反，点击一次，把最后一个元素取出，插入到数组的头部。arr.unshift(arr.pop())。 封装了一个运动框架，点击时，图片由当前位置，运动到下一个位置，可以调用这个框架，实现运动效果。 function getStyle(obj,sName){ return obj.currentStyle?obj.currentStyle[sName]:getComputedStyle(obj,false)[sName]; } function startMove(obj,json,options){ options=options||{}; options.duration=options.duration||700; options.easing=options.easing||&apos;ease-out&apos;; var start={};//开始 var dis={};//位移 for(var name in json){ start[name]=parseFloat(getStyle(obj,name)); //获取图片当前的信息 dis[name]=json[name]-start[name];//当前位置减去开始位置等于运动的距离 } var count=Math.floor(options.duration/30); var n=0; clearInterval(obj.timer); obj.timer=setInterval(function (){ n++; for(var name in json){ switch(options.easing){ case &apos;linear&apos;: var cur=start[name]+dis[name]*n/count; break; case &apos;ease-in&apos;: var cur=start[name]+dis[name]*Math.pow(n/count,3); break; case &apos;ease-out&apos;: var cur=start[name]+dis[name]*(1-Math.pow(1-n/count,3)); break; } if(name==&apos;opacity&apos;){ obj.style.opacity=cur; obj.style.filter=&apos;alpha(opacity:&apos;+cur*100+&apos;)&apos;; }else if(name==&apos;zIndex&apos;){ obj.style.zIndex=cur; }else{ obj.style[name]=cur+&apos;px&apos;; } } if(n==count){ clearInterval(obj.timer); options.complete&amp;&amp;options.complete(); } },30); } 完整的代码，点击这里查看这篇文章]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端rem布局]]></title>
    <url>%2F2016%2F12%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言 移动产品屏幕的尺寸多种多样，造成了前端开发不得不让代码适应不同的屏幕尺寸。比较常用的有流体布局，响应式布局，flex布局，rem布局。本文主要讲的是如何使用rem实现自适应。 为什么选择rem 我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位. 流体布局都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点。大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。 媒体查询是响应式设计的核心。它根据条件告诉浏览器如何为指定视图宽度渲染页面。使用媒体查询兼容各种设备，工作量大，效率低下。代码累赘，会出现隐藏无用的元素，加载时间加长。 Flex布局将成为未来布局的首选方案，主流浏览器也都支持。这个应该多学习一下。但是目前使用，仍然要顾及一些不升级浏览器的用户。 什么是rem 首先，先认识一下这个标签。说道rem，不得不提一下em。可能我比较笨，这两个单位我有时经常记混。 rem（font size of the root element）是指相对于根元素的字体大小的单位， em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。二者都是相对单位。 使用 手机端头部加入最常用的meta内容 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; rem是相对于根元素 &lt; html &gt; ，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。1rem=16px(浏览器html的像素，可以设定这个基准值），假如浏览器的html设为64px，则下面的元素则1rem=64px来运算。即css元素宽度(rem) = 设计稿元素宽度(px)/基准(20)。基准根据自己需求，定义大小。举个栗子： html{ font-size:20px; } .btn { width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center; } 实现原理及方法 因为rem是相对于根元素，所以我们只要动态的获取到窗口的大小，依据 根元素/设计稿尺寸=改变后字体大小/改变后窗口的大小就可以算出窗口改变后，字体的大小。 通过JS来调整html的字体大小，而在页面中的制作稿则统一使用rem这个单位来制作。关键代码如下： (function(doc, win) { var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function() { var clientWidth = docEl.clientWidth; if (!clientWidth) return; if (clientWidth &gt;= 750) { docEl.style.fontSize = &apos;100px&apos;; } else { docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;; } }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false); })(document, window); 这段代码的意思是：如果页面的宽度超过了750px，那么页面中html的font-size恒为100px，否则，页面中html的font-size的大小为： 100 * (当前页面宽度 / 750)。 这是把rem值转换成px的js代码，其中里面的320是设计稿的尺寸，20是基数，设计稿是640就把320改成640，基数尽量不要太小，不要小于12，chrome默认最小字体是12px； 总结 一般移动端采用rem布局也够用了。不过前端更新太快了，rem布局也将成为过去，有精力多研究一下flex布局，提高下逼格。]]></content>
      <tags>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面之返回顶部]]></title>
    <url>%2F2016%2F12%2F25%2Fmy-first-work%2F</url>
    <content type="text"><![CDATA[前言前几天写页面的时候，想加一个回到顶部的按钮，本来一个挺简单的效果，编写的时候，脑子一热，按钮里面加了一个a标签。等到写出来测试的时候，发现窗口一直抖动。试了好几次也不知道怎么解决，于是把a便签去掉，又神奇的没有问题了。现在总结一下，以后直接使用。 锚点&lt;a name=&quot;top&quot; id=&quot;top&quot;&gt;返回顶部&lt;/a&gt; 放置位置在标签之后随便找个地方放都可以，只要靠近顶部即可。 页面底部放置： &lt;a href=&quot;#top&quot; target=&quot;_self&quot;&gt;返回顶部&lt;/a&gt; #号 #号返回顶部是最最清丽脱俗的一种方法 &lt;a href=&quot;#&quot;&gt;返回顶部&lt;/a&gt; js设置返回顶部 就是一般看到的动画效果的返回顶部啦，我们通过设置基数计算每次执行定时器返回的值。 直接贴代码： &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;返回顶部&lt;/title&gt; &lt;style&gt; #btn { position: fixed; padding: 50px 100px; right: 10px; bottom: 10px; display: none; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn&apos;); var time = 2000; var timer = null; var flag = false; //设置开关 用户如返回途中滑动滚轮则关闭返回顶部 window.onscroll = function() { if (flag) { clearInterval(timer); } flag = true; //ff,chrome ie滚动不一样，要用兼容写法 var scrollT = document.documentElement.scrollTop || document.body.scrollTop; //滑动大于500时显示返回顶部按钮 if (scrollT &gt; 500) { oBtn.style.display = &apos;block&apos;; } else { oBtn.style.display = &apos;none&apos;; } }; //点击上去 oBtn.onclick = function() { var count = Math.floor(time / 30); //执行次数 var start = document.documentElement.scrollTop || document.body.scrollTop; //获取当前scrollTop值 var dis = 0 - start; //用于计算返回值的差 var n = 0; //每次执行之后加1，当等于总执行次数时关闭定时器 timer = setInterval(function() { n++; var num = 1 - n / count; //缓冲基数 当前执行次数/总执行次数 用于计算scrollTop值 var cur = start + dis * (1 - Math.pow(num, 10)); //当前scrollTop值计算 document.documentElement.scrollTop = document.body.scrollTop = cur; flag = false; if (n == count) { clearInterval(timer); } }, 30); }; }; &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;height:3000px;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;返回顶部&quot; id=&quot;btn&quot;&gt; &lt;/body&gt; &lt;/html&gt; jq设置返回顶部因为jq本身封装的动画函数，所以看起来是不是酸爽多了？ &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;返回顶部&lt;/title&gt; &lt;style&gt; #btn { position: fixed; padding: 50px 100px; right: 10px; bottom: 10px; display: none; } &lt;/style&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() { //当滚动条的位置处于距顶部500以下时，跳转链接出现，否则消失 $(function() { $(window).scroll(function() { if ($(window).scrollTop() &gt; 500) { $(&quot;#btn&quot;).fadeIn(1500); } else { $(&quot;#btn&quot;).fadeOut(1500); } }); //当点击跳转链接后，回到页面顶部位置 $(&quot;#btn&quot;).click(function() { $(&apos;body,html&apos;).animate({ scrollTop: 0 }, 1000); return false; }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;height:3000px&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;返回顶部&quot; id=&quot;btn&quot;&gt; &lt;/body&gt; &lt;/html&gt; 总结 现在我们看见形形色色的返回顶部，漂亮的动画看起来更吸引我们的眼球，但其实如果只是为了返回顶部加个#号也未尝不可，至少京东就是这么做的，用起来也并没有觉得缺少了动画，少了体验少了优雅，反正我觉得还好，每个网站都是动画效果，当今社会网站这么多，早就看麻木了，所以如果为了干净快捷，那就尝试一下#号返回吧！]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
